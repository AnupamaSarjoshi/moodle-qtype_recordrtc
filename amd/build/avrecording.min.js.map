{"version":3,"file":"avrecording.min.js","sources":["../src/avrecording.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n//\r\n\r\n/**\r\n * JavaScript to the recording work.\r\n *\r\n * We would like to thank the creators of atto_recordrtc, whose\r\n * work originally inspired this.\r\n *\r\n * This script uses some third-party JavaScript and loading that within Moodle/ES6\r\n * requires some contortions. The main classes here are:\r\n *\r\n * * Recorder - represents one recording widget. This works in a way that is\r\n *   not particularly specific to this question type.\r\n * * RecordRtcQuestion - represents one question, which may contain several recorders.\r\n *   It deals with the interaction between the recorders and the question.\r\n *\r\n * @module    qtype_recordrtc/avrecording\r\n * @copyright 2019 The Open University\r\n * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\n\r\nimport Log from 'core/log';\r\nimport ModalFactory from 'core/modal_factory';\r\n\r\n/**\r\n * Verify that the question type can work. If not, show a warning.\r\n *\r\n * @return {string} 'ok' if it looks OK, else 'nowebrtc' or 'nothttps' if there is a problem.\r\n */\r\nfunction checkCanWork() {\r\n    // Check APIs are known.\r\n    if (!(navigator.mediaDevices && window.MediaRecorder)) {\r\n        return 'nowebrtc';\r\n    }\r\n\r\n    // Check protocol (localhost).\r\n    if (location.protocol === 'https:' ||\r\n            location.host === 'localhost' || location.host === '127.0.0.1') {\r\n        return 'ok';\r\n    } else {\r\n        return 'nothttps';\r\n    }\r\n}\r\n\r\n/**\r\n * Object for actually doing the recording.\r\n *\r\n * The recorder can be in one of several states, which is stored in a data-state\r\n * attribute on the outer span (widget). The states are:\r\n *\r\n *  - new:       there is no recording yet. Button shows 'Start recording' (audio) or 'Start camera' (video).\r\n *  - starting:  (video only) camera has started, but we are not recording yet. Button show 'Start recording'.\r\n *  - recording: Media is being recorded. Pause button visible if allowed. Main button shows 'Stop'. Countdown displayed.\r\n *  - paused:    If pause was pressed. Media recording paused, but resumable. Pause button changed to say 'resume'.\r\n *  - saving:    Media being uploaded. Progress indication shown. Pause button hidden if was visible.\r\n *  - recorded:  Recording and upload complete. Buttons shows 'Record again'.\r\n *\r\n * @param {HTMLElement} widget the DOM node that is the top level of the whole recorder.\r\n * @param {(AudioSettings|VideoSettings)} mediaSettings information about the media type.\r\n * @param {Object} owner the object we are doing the recording for. Must provide three callback functions\r\n *                       showAlert notifyRecordingComplete notifyButtonStatesChanged.\r\n * @param {Object} uploadInfo object with fields uploadRepositoryId, draftItemId, contextId and maxUploadSize.\r\n * @constructor\r\n */\r\nfunction Recorder(widget, mediaSettings, owner, uploadInfo) {\r\n    /**\r\n     * @type {Recorder} reference to this recorder, for use in event handlers.\r\n     */\r\n    const recorder = this;\r\n\r\n    /**\r\n     * @type {MediaStream} during recording, the stream of incoming media.\r\n     */\r\n    let mediaStream = null;\r\n\r\n    /**\r\n     * @type {MediaRecorder} the recorder that is capturing stream.\r\n     */\r\n    let mediaRecorder = null;\r\n\r\n    /**\r\n     * @type {Blob[]} the chunks of data that have been captured so far during the current recording.\r\n     */\r\n    let chunks = [];\r\n\r\n    /**\r\n     * @type {number} number of bytes recorded so far, so we can auto-stop\r\n     * before hitting Moodle's file-size limit.\r\n     */\r\n    let bytesRecordedSoFar = 0;\r\n\r\n    /**\r\n     * @type {number} when paused, the time left in milliseconds, so we can auto-stop at the time limit.\r\n     */\r\n    let timeRemaining = 0;\r\n\r\n    /**\r\n     * @type {number} while recording, the time we reach the time-limit, so we can auto-stop then.\r\n     * This is milliseconds since Unix epoch, so comparable with Date.now().\r\n     */\r\n    let stopTime = 0;\r\n\r\n    /**\r\n     * @type {number} intervalID returned by setInterval() while the timer is running.\r\n     */\r\n    let countdownTicker = 0;\r\n\r\n    const button = widget.querySelector('button.qtype_recordrtc-main-button');\r\n    const pauseButton = widget.querySelector('.qtype_recordrtc-pause-button button');\r\n    const controlRow = widget.querySelector('.qtype_recordrtc-control-row');\r\n    const mediaElement = widget.querySelector('.qtype_recordrtc-media-player ' +\r\n        (mediaSettings.name === 'screen' ? 'video' : mediaSettings.name));\r\n    const noMediaPlaceholder = widget.querySelector('.qtype_recordrtc-no-recording-placeholder');\r\n    const timeDisplay = widget.querySelector('.qtype_recordrtc-time-left');\r\n    const progressBar = widget.querySelector('.qtype_recordrtc-time-left .qtype_recordrtc-timer-front');\r\n    const backTimeEnd = widget.querySelector('.qtype_recordrtc-time-left .qtype_recordrtc-timer-back span.timer-end');\r\n    const backtimeStart = widget.querySelector('.qtype_recordrtc-time-left .qtype_recordrtc-timer-back span.timer-start');\r\n    const frontTimeEnd = widget.querySelector('.qtype_recordrtc-time-left .qtype_recordrtc-timer-front span.timer-end');\r\n    const fronttimeStart = widget.querySelector('.qtype_recordrtc-time-left .qtype_recordrtc-timer-front span.timer-start');\r\n\r\n    widget.addEventListener('click', handleButtonClick);\r\n    this.uploadMediaToServer = uploadMediaToServer; // Make this method available.\r\n\r\n    /**\r\n     * Handles clicks on the start/stop and pause buttons.\r\n     *\r\n     * @param {Event} e\r\n     */\r\n    function handleButtonClick(e) {\r\n        const clickedButton = e.target.closest('button');\r\n        if (!clickedButton) {\r\n            return; // Not actually a button click.\r\n        }\r\n        e.preventDefault();\r\n        switch (widget.dataset.state) {\r\n            case 'new':\r\n            case 'recorded':\r\n                startRecording();\r\n                break;\r\n            case 'starting':\r\n                if (mediaSettings.name === 'screen') {\r\n                    startScreenSaving();\r\n                } else {\r\n                    startSaving();\r\n                }\r\n                break;\r\n            case 'recording':\r\n                if (clickedButton === pauseButton) {\r\n                    pause();\r\n                } else {\r\n                    stopRecording();\r\n                }\r\n                break;\r\n            case 'paused':\r\n                if (clickedButton === pauseButton) {\r\n                    resume();\r\n                } else {\r\n                    stopRecording();\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get list media device supported.\r\n     *\r\n     * @param {Function} A callback function to handle next step.\r\n     */\r\n    function getMediaDevices(callback) {\r\n        navigator.mediaDevices.enumerateDevices().then(callback).catch(handleScreenSharingError);\r\n    }\r\n\r\n    /**\r\n     * Get audio mic stream.\r\n     *\r\n     * @param {Function} A callback function to handle next step.\r\n     */\r\n    function getAudioMedia(callback) {\r\n        navigator.mediaDevices.getUserMedia({audio: true}).then(callback).catch(handleScreenSharingError);\r\n    }\r\n\r\n    /**\r\n     * To handle every time the audio mic has a problem.\r\n     * For now, we will allow video to be saved without sound when there is an error with the microphone.\r\n     *\r\n     * @param {Object} A error object.\r\n     */\r\n    function handleScreenSharingError(error) {\r\n        Log.debug(error);\r\n        startSaving();\r\n    }\r\n\r\n    /**\r\n     * When recorder type is screen, we need add audio mic stream into mediaStream\r\n     * before saving.\r\n     */\r\n    function startScreenSaving() {\r\n        // We need to combine 2 audio and screen-sharing streams to create a recording with audio from the mic.\r\n        getMediaDevices(devices => {\r\n            let composedStream = new MediaStream();\r\n            // Get audio stream from microphone.\r\n            getAudioMedia(micStream => {\r\n                // When the user shares their screen, we need to merge the video track from the media stream with\r\n                // the audio track from the microphone stream and stop any unnecessary tracks to ensure\r\n                // that the recorded video has microphone sound.\r\n                mediaStream.getTracks().forEach(function(track) {\r\n                    if (track.kind === 'video') {\r\n                        // Add video track into stream.\r\n                        composedStream.addTrack(track);\r\n                    } else {\r\n                        // Stop any audio track.\r\n                        track.stop();\r\n                    }\r\n                });\r\n\r\n                // Add mic audio track from mic stream into composedStream to track audio.\r\n                // This will make sure the recorded video will have mic sound.\r\n                micStream.getAudioTracks().forEach(function(micTrack) {\r\n                    composedStream.addTrack(micTrack);\r\n                });\r\n                mediaStream = composedStream;\r\n                startSaving();\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Start recording (because the button was clicked).\r\n     */\r\n    function startRecording() {\r\n\r\n        // Reset timer label.\r\n        setLabelForTimer(0, parseInt(widget.dataset.maxRecordingDuration));\r\n\r\n        if (mediaSettings.name === 'audio') {\r\n            mediaElement.parentElement.classList.add('hide');\r\n            noMediaPlaceholder.classList.add('hide');\r\n            timeDisplay.classList.remove('hide');\r\n\r\n        } else {\r\n            mediaElement.parentElement.classList.remove('hide');\r\n            noMediaPlaceholder.classList.add('hide');\r\n        }\r\n        pauseButton?.parentElement.classList.remove('hide');\r\n\r\n        // Change look of recording button.\r\n        button.classList.remove('btn-outline-danger');\r\n        button.classList.add('btn-danger');\r\n\r\n        // Disable other question buttons when current widget stared recording.\r\n        disableAllButtons();\r\n\r\n        // Empty the array containing the previously recorded chunks.\r\n        chunks = [];\r\n        bytesRecordedSoFar = 0;\r\n        if (mediaSettings.name === 'screen') {\r\n            navigator.mediaDevices.getDisplayMedia(mediaSettings.mediaConstraints)\r\n                .then(handleCaptureStarting)\r\n                .catch(handleCaptureFailed);\r\n        } else {\r\n            navigator.mediaDevices.getUserMedia(mediaSettings.mediaConstraints)\r\n                .then(handleCaptureStarting)\r\n                .catch(handleCaptureFailed);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback once getUserMedia has permission from the user to access the recording devices.\r\n     *\r\n     * @param {MediaStream} stream the stream to record.\r\n     */\r\n    function handleCaptureStarting(stream) {\r\n        mediaStream = stream;\r\n\r\n        // Setup the UI for during recording.\r\n        mediaElement.srcObject = stream;\r\n        mediaElement.muted = true;\r\n        if (mediaSettings.name === 'audio') {\r\n            startSaving();\r\n        } else {\r\n            // Cover when user clicks Browser's \"Stop Sharing Screen\" button.\r\n            if (mediaSettings.name === 'screen') {\r\n                mediaStream.getVideoTracks()[0].addEventListener('ended', handleStopSharing);\r\n            }\r\n            mediaElement.play();\r\n            mediaElement.controls = false;\r\n\r\n            widget.dataset.state = 'starting';\r\n            setButtonLabel('startrecording');\r\n            widget.querySelector('.qtype_recordrtc-stop-button').disabled = false;\r\n        }\r\n\r\n        // Make button clickable again, to allow starting/stopping recording.\r\n        if (pauseButton) {\r\n            pauseButton.disabled = false;\r\n        }\r\n        button.disabled = false;\r\n        button.focus();\r\n    }\r\n\r\n    /**\r\n     * For recording types which show the media during recording,\r\n     * this starts the loop-back display, but does not start recording it yet.\r\n     */\r\n    function startSaving() {\r\n        // Initialize MediaRecorder events and start recording.\r\n        mediaRecorder = new MediaRecorder(mediaStream, getRecordingOptions());\r\n\r\n        mediaRecorder.ondataavailable = handleDataAvailable;\r\n        mediaRecorder.onpause = handleDataAvailable;\r\n        mediaRecorder.onstop = handleRecordingHasStopped;\r\n        mediaRecorder.start(1000); // Capture in one-second chunks. Firefox requires that.\r\n\r\n        widget.dataset.state = 'recording';\r\n        // Set duration for progressbar and start animate.\r\n        progressBar.style.animationDuration = widget.dataset.maxRecordingDuration + 's';\r\n        progressBar.classList.add('animate');\r\n        setButtonLabel('stoprecording');\r\n        startCountdownTimer();\r\n        if (mediaSettings.name === 'video' || mediaSettings.name === 'screen') {\r\n            button.parentElement.classList.add('hide');\r\n            controlRow.classList.remove('hide');\r\n            controlRow.classList.add('d-flex');\r\n            timeDisplay.classList.remove('hide');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback that is called by the user clicking Stop screen sharing on the browser.\r\n     */\r\n    function handleStopSharing() {\r\n        if (widget.dataset.state === 'starting') {\r\n            widget.dataset.state = 'new';\r\n            mediaElement.parentElement.classList.add('hide');\r\n            noMediaPlaceholder.classList.remove('hide');\r\n            setButtonLabel('startsharescreen');\r\n            button.blur();\r\n        } else {\r\n            const controlEl = widget.querySelector('.qtype_recordrtc-control-row');\r\n            if (!controlEl.classList.contains('hide')) {\r\n                controlEl.querySelector('.qtype_recordrtc-stop-button').click();\r\n            }\r\n        }\r\n        enableAllButtons();\r\n    }\r\n\r\n    /**\r\n     * Callback that is called by the media system for each Chunk of data.\r\n     *\r\n     * @param {BlobEvent} event\r\n     */\r\n    function handleDataAvailable(event) {\r\n        if (!event.data) {\r\n            return; // It seems this can happen around pausing.\r\n        }\r\n\r\n        // Check there is space to store the next chunk, and if not stop.\r\n        bytesRecordedSoFar += event.data.size;\r\n        if (uploadInfo.maxUploadSize >= 0 && bytesRecordedSoFar >= uploadInfo.maxUploadSize) {\r\n\r\n            // Extra check to avoid alerting twice.\r\n            if (!localStorage.getItem('alerted')) {\r\n                localStorage.setItem('alerted', 'true');\r\n                stopRecording();\r\n                owner.showAlert('nearingmaxsize');\r\n\r\n            } else {\r\n                localStorage.removeItem('alerted');\r\n            }\r\n        }\r\n\r\n        // Store the next chunk of data.\r\n        chunks.push(event.data);\r\n\r\n        // Notify form-change-checker that there is now unsaved data.\r\n        // But, don't do this in question preview where it is just annoying.\r\n        if (typeof M.core_formchangechecker !== 'undefined' &&\r\n            !window.location.pathname.endsWith('/question/preview.php')) {\r\n            M.core_formchangechecker.set_form_changed();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Pause recording.\r\n     */\r\n    function pause() {\r\n        // Stop the count-down timer.\r\n        stopCountdownTimer();\r\n        setPauseButtonLabel('resume');\r\n        mediaRecorder.pause();\r\n        widget.dataset.state = 'paused';\r\n        // Pause animate.\r\n        toggleProgressbarState();\r\n    }\r\n\r\n    /**\r\n     * Continue recording.\r\n     */\r\n    function resume() {\r\n        // Stop the count-down timer.\r\n        resumeCountdownTimer();\r\n        widget.dataset.state = 'recording';\r\n        setPauseButtonLabel('pause');\r\n        mediaRecorder.resume();\r\n        // Resume animate.\r\n        toggleProgressbarState();\r\n    }\r\n\r\n    /**\r\n     * Start recording (because the button was clicked or because we have reached a limit).\r\n     */\r\n    function stopRecording() {\r\n        // Disable the button while things change.\r\n        button.disabled = true;\r\n\r\n        // Stop the count-down timer.\r\n        stopCountdownTimer();\r\n\r\n        // Update the button.\r\n        button.classList.remove('btn-danger');\r\n        button.classList.add('btn-outline-danger');\r\n        if (pauseButton) {\r\n            setPauseButtonLabel('pause');\r\n            pauseButton.parentElement.classList.add('hide');\r\n        }\r\n\r\n        // Reset animation state.\r\n        progressBar.style.animationPlayState = 'running';\r\n        // Stop animate.\r\n        progressBar.classList.remove('animate');\r\n\r\n        // Ask the recording to stop.\r\n        mediaRecorder.stop();\r\n\r\n        // Also stop each individual MediaTrack.\r\n        const tracks = mediaStream.getTracks();\r\n        for (let i = 0; i < tracks.length; i++) {\r\n            tracks[i].stop();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback that is called by the media system once recording has finished.\r\n     */\r\n    function handleRecordingHasStopped() {\r\n        if (widget.dataset.state === 'new') {\r\n            // This can happens if an error occurs when recording is starting. Do nothing.\r\n            return;\r\n        }\r\n\r\n        // Set source of the media player.\r\n        const blob = new Blob(chunks, {type: mediaRecorder.mimeType});\r\n        mediaElement.srcObject = null;\r\n        mediaElement.src = URL.createObjectURL(blob);\r\n\r\n        // Show audio player with controls enabled, and unmute.\r\n        mediaElement.muted = false;\r\n        mediaElement.controls = true;\r\n        mediaElement.parentElement.classList.remove('hide');\r\n        noMediaPlaceholder.classList.add('hide');\r\n        mediaElement.focus();\r\n\r\n        if (mediaSettings.name === 'audio') {\r\n            timeDisplay.classList.add('hide');\r\n\r\n        } else {\r\n            button.parentElement.classList.remove('hide');\r\n            controlRow.classList.add('hide');\r\n            controlRow.classList.remove('d-flex');\r\n        }\r\n\r\n        // Ensure the button while things change.\r\n        button.disabled = true;\r\n        button.classList.remove('btn-danger');\r\n        button.classList.add('btn-outline-danger');\r\n        widget.dataset.state = 'recorded';\r\n\r\n        if (chunks.length > 0) {\r\n            owner.notifyRecordingComplete(recorder);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Function that handles errors from the recorder.\r\n     *\r\n     * @param {DOMException} error\r\n     */\r\n    function handleCaptureFailed(error) {\r\n        Log.debug('Audio/video/screen question: error received');\r\n        Log.debug(error);\r\n\r\n        setPlaceholderMessage('recordingfailed');\r\n        setButtonLabel('recordagainx');\r\n        button.classList.remove('btn-danger');\r\n        button.classList.add('btn-outline-danger');\r\n        widget.dataset.state = 'new';\r\n        // Hide time display.\r\n        timeDisplay.classList.add('hide');\r\n\r\n        if (mediaRecorder && mediaRecorder.state !== 'inactive') {\r\n            mediaRecorder.stop();\r\n        }\r\n\r\n        // Changes 'CertainError' -> 'gumcertain' to match language string names.\r\n        const stringName = 'gum' + error.name.replace('Error', '').toLowerCase();\r\n\r\n        owner.showAlert(stringName);\r\n        enableAllButtons();\r\n    }\r\n\r\n    /**\r\n     * Start the countdown timer.\r\n     */\r\n    function startCountdownTimer() {\r\n        timeRemaining = widget.dataset.maxRecordingDuration * 1000;\r\n        resumeCountdownTimer();\r\n        updateTimerDisplay();\r\n    }\r\n\r\n    /**\r\n     * Stop the countdown timer.\r\n     */\r\n    function stopCountdownTimer() {\r\n        timeRemaining = stopTime - Date.now();\r\n        if (countdownTicker !== 0) {\r\n            clearInterval(countdownTicker);\r\n            countdownTicker = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Start or resume the countdown timer.\r\n     */\r\n    function resumeCountdownTimer() {\r\n        stopTime = Date.now() + timeRemaining;\r\n        if (countdownTicker === 0) {\r\n            countdownTicker = setInterval(updateTimerDisplay, 100);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the countdown timer, and stop recording if we have reached 0.\r\n     */\r\n    function updateTimerDisplay() {\r\n        const millisecondsRemaining = stopTime - Date.now();\r\n        const secondsRemaining = Math.round(millisecondsRemaining / 1000);\r\n        const secondsStart = widget.dataset.maxRecordingDuration - secondsRemaining;\r\n        // Set time label for elements.\r\n        setLabelForTimer(secondsStart, secondsRemaining);\r\n        if (millisecondsRemaining <= 0) {\r\n            stopRecording();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get time label for timer.\r\n     *\r\n     * @param {number} seconds The time in seconds.\r\n     * @return {string} The label for timer. e.g. '00:00' or '10:00'.\r\n     */\r\n    function getTimeLabelForTimer(seconds) {\r\n        const secs = seconds % 60;\r\n        const mins = Math.round((seconds - secs) / 60);\r\n\r\n        return M.util.get_string('timedisplay', 'qtype_recordrtc',\r\n            {mins: pad(mins), secs: pad(secs)});\r\n    }\r\n\r\n    /**\r\n     * Set time label for timer.\r\n     * We need to update the labels for both the timer back(whose background color is white) and\r\n     * timer front (with blue background) to create a text effect that contrasts with the background color.\r\n     *\r\n     * @param {Number} secondsStart The second start. e.g: With duration 1 minute\r\n     * secondsStart will start from 0 and increase up to 60.\r\n     * @param {Number} secondsRemaining The second remaining. e.g: With duration 1 minute\r\n     * secondsRemaining will decrease from 60 to 0.\r\n     */\r\n    function setLabelForTimer(secondsStart, secondsRemaining) {\r\n        // Set time label for timer back.\r\n        backTimeEnd.innerText = getTimeLabelForTimer(secondsRemaining);\r\n        backtimeStart.innerText = getTimeLabelForTimer(secondsStart);\r\n        // Set time label for timer front.\r\n        frontTimeEnd.innerText = getTimeLabelForTimer(secondsRemaining);\r\n        fronttimeStart.innerText = getTimeLabelForTimer(secondsStart);\r\n    }\r\n\r\n    /**\r\n     * Zero-pad a string to be at least two characters long.\r\n     *\r\n     * @param {number} val e.g. 1 or 10\r\n     * @return {string} e.g. '01' or '10'.\r\n     */\r\n    function pad(val) {\r\n        const valString = val + '';\r\n\r\n        if (valString.length < 2) {\r\n            return '0' + valString;\r\n        } else {\r\n            return '' + valString;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Trigger the upload of the recorded media back to Moodle.\r\n     */\r\n    function uploadMediaToServer() {\r\n        setButtonLabel('uploadpreparing');\r\n\r\n        // First we need to get the media data from the media element.\r\n        const fetchRequest = new XMLHttpRequest();\r\n        fetchRequest.open('GET', mediaElement.src);\r\n        fetchRequest.responseType = 'blob';\r\n        fetchRequest.addEventListener('load', handleRecordingFetched);\r\n        fetchRequest.send();\r\n    }\r\n\r\n    /**\r\n     * Callback called once we have the data from the media element, ready to upload to Moodle.\r\n     *\r\n     * @param {ProgressEvent} e\r\n     */\r\n    function handleRecordingFetched(e) {\r\n        const fetchRequest = e.target;\r\n        if (fetchRequest.status !== 200) {\r\n            // No data.\r\n            return;\r\n        }\r\n\r\n        // Blob is now the media that the audio/video tag's src pointed to.\r\n        const blob = fetchRequest.response;\r\n\r\n        // Create FormData to send to PHP filepicker-upload script.\r\n        const formData = new FormData();\r\n        formData.append('repo_upload_file', blob, widget.dataset.recordingFilename);\r\n        formData.append('sesskey', M.cfg.sesskey);\r\n        formData.append('repo_id', uploadInfo.uploadRepositoryId);\r\n        formData.append('itemid', uploadInfo.draftItemId);\r\n        formData.append('savepath', '/');\r\n        formData.append('ctx_id', uploadInfo.contextId);\r\n        formData.append('overwrite', '1');\r\n\r\n        const uploadRequest = new XMLHttpRequest();\r\n        uploadRequest.addEventListener('readystatechange', handleUploadReadyStateChanged);\r\n        uploadRequest.upload.addEventListener('progress', handleUploadProgress);\r\n        uploadRequest.addEventListener('error', handleUploadError);\r\n        uploadRequest.addEventListener('abort', handleUploadAbort);\r\n        uploadRequest.open('POST', M.cfg.wwwroot + '/repository/repository_ajax.php?action=upload');\r\n        uploadRequest.send(formData);\r\n    }\r\n\r\n    /**\r\n     * Callback for when the upload completes.\r\n     * @param {ProgressEvent} e\r\n     */\r\n    function handleUploadReadyStateChanged(e) {\r\n        const uploadRequest = e.target;\r\n        if (uploadRequest.readyState !== 4) {\r\n            return; // Not finished yet. We will get more of these events when it is.\r\n        }\r\n\r\n        const response = JSON.parse(uploadRequest.responseText);\r\n        if (response.errorcode) {\r\n            handleUploadError(); // Moodle sends back errors with a 200 status code for some reason!\r\n        }\r\n\r\n        if (uploadRequest.status === 200) {\r\n            // When request finished and successful.\r\n            setButtonLabel('recordagainx');\r\n            button.classList.remove('btn-outline-danger');\r\n            enableAllButtons();\r\n        } else if (uploadRequest.status === 404) {\r\n            setPlaceholderMessage('uploadfailed404');\r\n            enableAllButtons();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback for updating the upload progress.\r\n     * @param {ProgressEvent} e\r\n     */\r\n    function handleUploadProgress(e) {\r\n        setButtonLabel('uploadprogress', Math.round(e.loaded / e.total * 100) + '%');\r\n    }\r\n\r\n    /**\r\n     * Callback for when the upload fails with an error.\r\n     */\r\n    function handleUploadError() {\r\n        setPlaceholderMessage('uploadfailed');\r\n        enableAllButtons();\r\n    }\r\n\r\n    /**\r\n     * Callback for when the upload fails with an error.\r\n     */\r\n    function handleUploadAbort() {\r\n        setPlaceholderMessage('uploadaborted');\r\n        enableAllButtons();\r\n    }\r\n\r\n    /**\r\n     * Display a progress message in the upload progress area.\r\n     *\r\n     * @param {string} langString\r\n     * @param {string|null} [a] optional variable to populate placeholder with\r\n     */\r\n    function setButtonLabel(langString, a) {\r\n        if (!a) {\r\n            // Seemingly unnecessary space inside the span is needed for screen-readers, and it must be a non-breaking space.\r\n            a = '<span class=\"sr-only\">&nbsp;' + widget.dataset.widgetName + '</span>';\r\n        }\r\n        button.innerHTML = M.util.get_string(langString, 'qtype_recordrtc', a);\r\n    }\r\n\r\n    /**\r\n     * Display a progress message in the upload progress area.\r\n     *\r\n     * @param {string} langString\r\n     */\r\n    function setPauseButtonLabel(langString) {\r\n        pauseButton.innerText = M.util.get_string(langString, 'qtype_recordrtc');\r\n    }\r\n\r\n    /**\r\n     * Display a message in the upload progress area.\r\n     *\r\n     * @param {string} langString\r\n     */\r\n    function setPlaceholderMessage(langString) {\r\n        noMediaPlaceholder.textContent = M.util.get_string(langString, 'qtype_recordrtc');\r\n        mediaElement.parentElement.classList.add('hide');\r\n        noMediaPlaceholder.classList.remove('hide');\r\n    }\r\n\r\n    /**\r\n     * Select best options for the recording codec.\r\n     *\r\n     * @returns {Object}\r\n     */\r\n    function getRecordingOptions() {\r\n        const options = {};\r\n\r\n        // Get the relevant bit rates from settings.\r\n        if (mediaSettings.name === 'audio') {\r\n            options.audioBitsPerSecond = mediaSettings.bitRate;\r\n        } else if (mediaSettings.name === 'video' || mediaSettings.name === 'screen') {\r\n            options.videoBitsPerSecond = mediaSettings.bitRate;\r\n            options.videoWidth = mediaSettings.width;\r\n            options.videoHeight = mediaSettings.height;\r\n\r\n            // Go through our list of mimeTypes, and take the first one that will work.\r\n            for (let i = 0; i < mediaSettings.mimeTypes.length; i++) {\r\n                if (MediaRecorder.isTypeSupported(mediaSettings.mimeTypes[i])) {\r\n                    options.mimeType = mediaSettings.mimeTypes[i];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return options;\r\n    }\r\n\r\n    /**\r\n     * Enable all buttons in the question.\r\n     */\r\n    function enableAllButtons() {\r\n        disableOrEnableButtons(true);\r\n        owner.notifyButtonStatesChanged();\r\n    }\r\n\r\n    /**\r\n     * Disable all buttons in the question.\r\n     */\r\n    function disableAllButtons() {\r\n        disableOrEnableButtons(false);\r\n    }\r\n\r\n    /**\r\n     * Disables/enables other question buttons when current widget started recording/finished recording.\r\n     *\r\n     * @param {boolean} enabled true if the button should be enabled.\r\n     */\r\n    function disableOrEnableButtons(enabled = false) {\r\n        widget.closest('.que').querySelectorAll('button, input[type=submit], input[type=button]').forEach(\r\n            function(button) {\r\n                button.disabled = !enabled;\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Pause/resume the progressbar state.\r\n     */\r\n    function toggleProgressbarState() {\r\n        const running = progressBar.style.animationPlayState || 'running';\r\n        progressBar.style.animationPlayState = running === 'running' ? 'paused' : 'running';\r\n    }\r\n}\r\n\r\n/**\r\n * Object that controls the settings for recording audio.\r\n *\r\n * @param {string} bitRate desired audio bitrate.\r\n * @constructor\r\n */\r\nfunction AudioSettings(bitRate) {\r\n    this.name = 'audio';\r\n    this.bitRate = parseInt(bitRate, 10);\r\n    this.mediaConstraints = {\r\n        audio: true\r\n    };\r\n    this.mimeTypes = [\r\n        'audio/webm;codecs=opus',\r\n        'audio/ogg;codecs=opus'\r\n    ];\r\n}\r\n\r\n/**\r\n * Object that controls the settings for recording video.\r\n *\r\n * @param {string} bitRate desired video bitrate.\r\n * @param {string} width desired width.\r\n * @param {string} height desired height.\r\n * @constructor\r\n */\r\nfunction VideoSettings(bitRate, width, height) {\r\n    this.name = 'video';\r\n    this.bitRate = parseInt(bitRate, 10);\r\n    this.width = parseInt(width, 10);\r\n    this.height = parseInt(height, 10);\r\n    this.mediaConstraints = {\r\n        audio: true,\r\n        video: {\r\n            width: {ideal: this.width},\r\n            height: {ideal: this.height}\r\n        }\r\n    };\r\n    this.mimeTypes = [\r\n        'video/webm;codecs=vp9,opus',\r\n        'video/webm;codecs=h264,opus',\r\n        'video/webm;codecs=vp8,opus'\r\n    ];\r\n}\r\n\r\n/**\r\n * Object that controls the settings for recording screen.\r\n *\r\n * @param {string} bitRate desired screen bitrate.\r\n * @param {string} width desired width.\r\n * @param {string} height desired height.\r\n * @constructor\r\n */\r\nfunction ScreenSettings(bitRate, width, height) {\r\n    this.name = 'screen';\r\n    this.bitRate = parseInt(bitRate, 10);\r\n    this.width = parseInt(width, 10);\r\n    this.height = parseInt(height, 10);\r\n    this.mediaConstraints = {\r\n        audio: true,\r\n        systemAudio: 'exclude',\r\n        video: {\r\n            displaySurface: 'monitor',\r\n            frameRate: {ideal: 24},\r\n            // Currently, Safari does not support ideal constraints for width and height with screen sharing feature.\r\n            // It may be supported in version 16.4.\r\n            width: {max: this.width},\r\n            height: {max: this.height},\r\n        }\r\n    };\r\n\r\n    // We use vp8 as the default codec. If it is not supported, we will switch to another codec.\r\n    this.mimeTypes = [\r\n        'video/webm;codecs=vp8,opus',\r\n        'video/webm;codecs=vp9,opus',\r\n        'video/webm;codecs=h264,opus',\r\n    ];\r\n}\r\n\r\n/**\r\n * Represents one record audio or video question.\r\n *\r\n * @param {string} questionId id of the outer question div.\r\n * @param {Object} settings like audio bit rate.\r\n * @constructor\r\n */\r\nfunction RecordRtcQuestion(questionId, settings) {\r\n    const questionDiv = document.getElementById(questionId);\r\n\r\n    // Check if the RTC API can work here.\r\n    const result = checkCanWork();\r\n    if (result === 'nothttps') {\r\n        questionDiv.querySelector('.https-warning').classList.remove('hide');\r\n        return;\r\n    } else if (result === 'nowebrtc') {\r\n        questionDiv.querySelector('.no-webrtc-warning').classList.remove('hide');\r\n        return;\r\n    }\r\n\r\n    // Make the callback functions available.\r\n    this.showAlert = showAlert;\r\n    this.notifyRecordingComplete = notifyRecordingComplete;\r\n    this.notifyButtonStatesChanged = setSubmitButtonState;\r\n    const thisQuestion = this;\r\n\r\n    // We may have more than one widget in a question.\r\n    questionDiv.querySelectorAll('.qtype_recordrtc-audio-widget, .qtype_recordrtc-video-widget, .qtype_recordrtc-screen-widget')\r\n        .forEach(function(widget) {\r\n            // Get the appropriate options.\r\n            let typeInfo;\r\n            switch (widget.dataset.mediaType) {\r\n                case 'audio':\r\n                    typeInfo = new AudioSettings(settings.audioBitRate);\r\n                    break;\r\n                case 'screen':\r\n                    typeInfo = new ScreenSettings(settings.screenBitRate, settings.screenWidth, settings.screenHeight);\r\n                    break;\r\n                default:\r\n                    typeInfo = new VideoSettings(settings.videoBitRate, settings.videoWidth, settings.videoHeight);\r\n                    break;\r\n            }\r\n\r\n            // Create the recorder.\r\n            new Recorder(widget, typeInfo, thisQuestion, settings);\r\n            return 'Not used';\r\n        });\r\n    setSubmitButtonState();\r\n\r\n    /**\r\n     * Set the state of the question's submit button.\r\n     *\r\n     * If any recorder does not yet have a recording, then disable the button.\r\n     * Otherwise, enable it.\r\n     */\r\n    function setSubmitButtonState() {\r\n        let anyRecorded = false;\r\n        questionDiv.querySelectorAll('.qtype_recordrtc-audio-widget, .qtype_recordrtc-video-widget, .qtype_recordrtc-screen-widget')\r\n            .forEach(function(widget) {\r\n                if (widget.dataset.state === 'recorded') {\r\n                    anyRecorded = true;\r\n                }\r\n            });\r\n        const submitButton = questionDiv.querySelector('input.submit[type=submit]');\r\n        if (submitButton) {\r\n            submitButton.disabled = !anyRecorded;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Show a modal alert.\r\n     *\r\n     * @param {string} subject Subject is the content of the alert (which error the alert is for).\r\n     * @return {Promise}\r\n     */\r\n    function showAlert(subject) {\r\n        return ModalFactory.create({\r\n            type: ModalFactory.types.ALERT,\r\n            title: M.util.get_string(subject + '_title', 'qtype_recordrtc'),\r\n            body: M.util.get_string(subject, 'qtype_recordrtc'),\r\n        }).then(function(modal) {\r\n            modal.show();\r\n            return modal;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Callback called when the recording is completed.\r\n     *\r\n     * @param {Recorder} recorder the recorder.\r\n     */\r\n    function notifyRecordingComplete(recorder) {\r\n        recorder.uploadMediaToServer();\r\n    }\r\n}\r\n\r\n/**\r\n * Initialise a record audio or video question.\r\n *\r\n * @param {string} questionId id of the outer question div.\r\n * @param {Object} settings like audio bit rate.\r\n */\r\nfunction init(questionId, settings) {\r\n    M.util.js_pending('init-' + questionId);\r\n    new RecordRtcQuestion(questionId, settings);\r\n    M.util.js_complete('init-' + questionId);\r\n}\r\n\r\nexport {\r\n    init\r\n};\r\n"],"names":["Recorder","widget","mediaSettings","owner","uploadInfo","recorder","this","mediaStream","mediaRecorder","chunks","bytesRecordedSoFar","timeRemaining","stopTime","countdownTicker","button","querySelector","pauseButton","controlRow","mediaElement","name","noMediaPlaceholder","timeDisplay","progressBar","backTimeEnd","backtimeStart","frontTimeEnd","fronttimeStart","handleScreenSharingError","error","debug","startSaving","handleCaptureStarting","stream","srcObject","muted","getVideoTracks","addEventListener","handleStopSharing","play","controls","dataset","state","setButtonLabel","disabled","focus","MediaRecorder","options","audioBitsPerSecond","bitRate","videoBitsPerSecond","videoWidth","width","videoHeight","height","i","mimeTypes","length","isTypeSupported","mimeType","getRecordingOptions","ondataavailable","handleDataAvailable","onpause","onstop","handleRecordingHasStopped","start","style","animationDuration","maxRecordingDuration","classList","add","resumeCountdownTimer","updateTimerDisplay","parentElement","remove","blur","controlEl","contains","click","enableAllButtons","event","data","size","maxUploadSize","localStorage","getItem","removeItem","setItem","stopRecording","showAlert","push","M","core_formchangechecker","window","location","pathname","endsWith","set_form_changed","stopCountdownTimer","setPauseButtonLabel","animationPlayState","stop","tracks","getTracks","blob","Blob","type","src","URL","createObjectURL","notifyRecordingComplete","handleCaptureFailed","setPlaceholderMessage","stringName","replace","toLowerCase","Date","now","clearInterval","setInterval","millisecondsRemaining","secondsRemaining","Math","round","setLabelForTimer","getTimeLabelForTimer","seconds","secs","mins","util","get_string","pad","secondsStart","innerText","val","valString","handleRecordingFetched","e","fetchRequest","target","status","response","formData","FormData","append","recordingFilename","cfg","sesskey","uploadRepositoryId","draftItemId","contextId","uploadRequest","XMLHttpRequest","handleUploadReadyStateChanged","upload","handleUploadProgress","handleUploadError","handleUploadAbort","open","wwwroot","send","readyState","JSON","parse","responseText","errorcode","loaded","total","langString","a","widgetName","innerHTML","textContent","disableOrEnableButtons","notifyButtonStatesChanged","enabled","closest","querySelectorAll","forEach","toggleProgressbarState","running","clickedButton","preventDefault","parseInt","navigator","mediaDevices","getDisplayMedia","mediaConstraints","then","catch","getUserMedia","startRecording","callback","devices","composedStream","MediaStream","micStream","track","kind","addTrack","getAudioTracks","micTrack","audio","enumerateDevices","pause","resume","uploadMediaToServer","responseType","AudioSettings","VideoSettings","video","ideal","ScreenSettings","systemAudio","displaySurface","frameRate","max","RecordRtcQuestion","questionId","settings","questionDiv","document","getElementById","result","protocol","host","subject","ModalFactory","create","types","ALERT","title","body","modal","show","setSubmitButtonState","thisQuestion","anyRecorded","submitButton","typeInfo","mediaType","audioBitRate","screenBitRate","screenWidth","screenHeight","videoBitRate","js_pending","js_complete"],"mappings":"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"}